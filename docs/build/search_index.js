var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"I have (very much not rigorously) benchmarked Mice.jl using the test dataset [3], and also performed an equivalent benchmark of the R package mice.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"System info: Single-threaded execution, Intel® Core™ i7-12700H 2.30GHz CPU, 32GB 4800MHz DDR5 RAM, running Windows 11 version 10.0.22621.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"R: version 4.3.1 running mice version 3.16.0. Julia: version 1.9.2 running Mice.jl version 0.0.0.","category":"page"},{"location":"benchmarks/#Imputation-(mice)","page":"Benchmarks","title":"Imputation (mice)","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"15 iterations were completed to impute 12 variables (of which 4 binary categorical, 1 other categorical and 7 numeric) using a set of 18 predictors (those 12 variables plus 6 complete variables: 1 binary categorical, 2 other categorical and 3 numeric). In Mice.jl, gcSchedule was set to 0.3.","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Number of imputations R (mice) (s) Mice.jl (s)\n1 1.88 27.01\n5 8.84 28.72\n10 18.14 30.81\n20 38.42 36.34\n50 96.78 51.95\n100 199.33 79.52","category":"page"},{"location":"benchmarks/#Why-is-Mice.jl-so-slow-for-small-jobs?","page":"Benchmarks","title":"Why is Mice.jl so slow for small jobs?","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Julia is a compiled language. This means that the first time a function is run, it is compiled into machine code, which takes time. Therefore, the first iteration of mice() will be (much) slower in Julia than in R, for example. However, subsequent iterations will be much faster, as all of the required functions are already compiled.","category":"page"},{"location":"benchmarks/#Why-is-the-first-iteration-so-much-slower-than-the-rest?","page":"Benchmarks","title":"Why is the first iteration so much slower than the rest?","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"See above.","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"A. Gelman and T. Raghunathan. Multivariate missing data. In: Flexible imputation of missing data, 2nd Edition (Chapman and Hall/CRC, 2018); pp. 105–138.\n\n\n\nD. B. Rubin. Multiple imputation for nonresponse in surveys. 1st Edition (John Wiley & Sons, Ltd, New York, 1987). Accessed on Nov 8, 2023, https://onlinelibrary.wiley.com/doi/pdf/10.1002/9780470316696.\n\n\n\nE. R. Dickson, P. M. Grambsch, T. R. Fleming, L. D. Fisher and A. Langworthy. Prognosis in primary biliary cirrhosis: Model for decision making. Hepatology 10, 1–7 (1989), https://onlinelibrary.wiley.com/doi/pdf/10.1002/hep.1840100102.\n\n\n\nS. van Buuren and K. Groothuis-Oudshoorn, mice: Multivariate Imputation by Chained Equations in R. Journal of Statistical Software 45, 1–67 (2011), https://doi.org/10.18637/jss.v045.i03.\n\n\n\n","category":"page"},{"location":"acknowledgements/#Acknowledgements","page":"Acknowledgements","title":"Acknowledgements","text":"","category":"section"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"This package is based heavily on the existing R package {mice} by Stef van Buuren, Karin Groothuis-Oudshoorn and collaborators [4].","category":"page"},{"location":"acknowledgements/","page":"Acknowledgements","title":"Acknowledgements","text":"The development of this package was supported by the Wellcome Trust [218497].","category":"page"},{"location":"issues/#Issues","page":"Issues","title":"Issues","text":"","category":"section"},{"location":"issues/","page":"Issues","title":"Issues","text":"This package is an early work in progress, and issues should be expected. When you find issues, please report them on the issues page.","category":"page"},{"location":"analysis/#Analysis-(with)","page":"Analysis (with)","title":"Analysis (with)","text":"","category":"section"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"Once you have a Mids object containing imputed data, you can use it to perform repeated analyses.","category":"page"},{"location":"analysis/#Inspecting-imputed-data","page":"Analysis (with)","title":"Inspecting imputed data","text":"","category":"section"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"If you just want to inspect the outcome of the imputation process, you can use the complete function to fill in the missing values in the original data frame.","category":"page"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"complete","category":"page"},{"location":"analysis/#Mice.complete","page":"Analysis (with)","title":"Mice.complete","text":"complete(\n    mids::Mids,\n    imputation::Int\n    )\n\nProduces a DataFrame with missings replaced with imputed values from a multiply imputed dataset (Mids) object.\n\nThe Mids object must be supplied first.\n\nThe imputation argument is an integer identifying which specific imputation is to be used to fill in the missing values.\n\n\n\n\n\ncomplete(\n    mids::Mids,\n    action::String\n    )\n\nSummarises the outputs of all imputations in a multiply imputed dataset (Mids).\n\nThe Mids object must be supplied first.\n\nThe action argument is a string identifying what format the output should take. If specified as \"long\", the function will return a single DataFrame, containing the results of each imputation in succession with an identifier (imp). If specified as \"list\", the function will return a vector of individual DataFrames.\n\n\n\n\n\n","category":"function"},{"location":"analysis/#Data-analysis","page":"Analysis (with)","title":"Data analysis","text":"","category":"section"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"To perform a data analysis procedure on each imputed dataset in turn, use the with function. The with function returns the results of the analyses wrapped in a Mira object.","category":"page"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"Mira\nwith","category":"page"},{"location":"analysis/#Mice.Mira","page":"Analysis (with)","title":"Mice.Mira","text":"Mira\n\nA multiply imputed repeated analyses object.\n\nThe analyses are stored as a vector of analyses of individual imputations.\n\n\n\n\n\n","category":"type"},{"location":"analysis/#Mice.with","page":"Analysis (with)","title":"Mice.with","text":"with(\n    mids::Mids,\n    func::Function\n    )\n\nConducts repeated analyses of a multiply imputed dataset (Mids).\n\nThe function takes two arguments: firstly the Mids object itself, then a function (func). The function should take the form data -> analysisFunction(arguments, data, moreArguments...), where data represents the position of the data argument in the function.\n\nFor example: with(mids, data -> lm(@formula(y ~ x1 + x2), data))\n\n\n\n\n\n","category":"function"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"The with function requires the use of a closure, which then permits the function to run the specified analysis procedure on each imputed dataset in turn. For example:","category":"page"},{"location":"analysis/","page":"Analysis (with)","title":"Analysis (with)","text":"julia> using CSV, DataFrames, GLM, Mice, Random, Statistics\n\njulia> myData = CSV.read(\"test/data/cirrhosis.csv\", DataFrame);\n\n# Defining missing values\njulia> colsWithMissings = [\"Drug\", \"Ascites\", \"Hepatomegaly\", \"Spiders\", \"Cholesterol\", \"Copper\", \"Alk_Phos\", \"SGOT\", \"Tryglicerides\", \"Platelets\", \"Prothrombin\", \"Stage\"];\njulia> myData[!, colsWithMissings] = allowmissing(myData[!, colsWithMissings]);\njulia> for i in colsWithMissings\n    replace!(myData[!, i], \"NA\" => missing)\nend\njulia> for i in [\"Cholesterol\", \"Copper\", \"Alk_Phos\", \"SGOT\", \"Tryglicerides\", \"Platelets\", \"Prothrombin\"]\n    myData[!, i] = passmissing(x -> parse(Float64, x)).(myData[!, i])\nend\n\njulia> myMethods = makeMethods(myData);\njulia> myMethods[[\"ID\", \"N_Days\"]] .= \"\";\n\njulia> myPredictorMatrix = makePredictorMatrix(myData);\njulia> myPredictorMatrix[:, [\"ID\", \"N_Days\"]] .= false;\n\njulia> Random.seed!(1234); # Set random seed for reproducibility\n\njulia> imputedData = mice(myData, predictorMatrix = myPredictorMatrix, methods = myMethods);\n\njulia> analysesMeans = with(imputedData, data -> mean(data.Cholesterol));\n# returns Mira of the mean of Bilirubin in each imputed dataset\n\njulia> analysesLMs = with(imputedData, data -> lm(@formula(N_Days ~ Drug + Age + Stage + Bilirubin), data));\n# returns Mira of linear model outputs from each imputed dataset","category":"page"},{"location":"pooling/#Pooling-coefficients-(pool)","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"","category":"section"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"Once you have a Mira object containing the results of repeated analyses, you can use the pool function to pool the results. The pool function returns the pooled results wrapped in a Mipo object.","category":"page"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"Mipo\npool","category":"page"},{"location":"pooling/#Mice.Mipo","page":"Pooling coefficients (pool)","title":"Mice.Mipo","text":"Mipo\n\nA type for storing the pooled results of multiply imputed repeated analyses (Mira).\n\n\n\n\n\n","category":"type"},{"location":"pooling/#Mice.pool","page":"Pooling coefficients (pool)","title":"Mice.pool","text":"pool(mira::Mira)\n\nPools the results of multiply imputed repeated analyses (Mira). The function will work on any Mira object containing model outputs which are receptive to the coef, stderror and nobs functions from StatsAPI.jl.\n\n\n\n\n\n","category":"function"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"The pool function should work on any Mira of model outputs that accept the StatsAPI functions coef, stderror and nobs. Otherwise, you will get an error and you will need to pool the results manually in accordance with Rubin's rules [2].","category":"page"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"For example:","category":"page"},{"location":"pooling/","page":"Pooling coefficients (pool)","title":"Pooling coefficients (pool)","text":"julia> using CSV, DataFrames, GLM, Mice, Random\n\njulia> myData = CSV.read(\"test/data/cirrhosis.csv\", DataFrame);\n\n# Defining missing values\njulia> colsWithMissings = [\"Drug\", \"Ascites\", \"Hepatomegaly\", \"Spiders\", \"Cholesterol\", \"Copper\", \"Alk_Phos\", \"SGOT\", \"Tryglicerides\", \"Platelets\", \"Prothrombin\", \"Stage\"];\njulia> myData[!, colsWithMissings] = allowmissing(myData[!, colsWithMissings]);\njulia> for i in colsWithMissings\n    replace!(myData[!, i], \"NA\" => missing)\nend\njulia> for i in [\"Cholesterol\", \"Copper\", \"Alk_Phos\", \"SGOT\", \"Tryglicerides\", \"Platelets\", \"Prothrombin\"]\n    myData[!, i] = passmissing(x -> parse(Float64, x)).(myData[!, i])\nend\n\njulia> myMethods = makeMethods(myData);\njulia> myMethods[[\"ID\", \"N_Days\"]] .= \"\";\n\njulia> myPredictorMatrix = makePredictorMatrix(myData);\njulia> myPredictorMatrix[:, [\"ID\", \"N_Days\"]] .= false;\n\njulia> Random.seed!(1234); # Set random seed for reproducibility\n\njulia> imputedData = mice(myData, predictorMatrix = myPredictorMatrix, methods = myMethods);\n\njulia> analysesLMs = with(imputedData, data -> lm(@formula(N_Days ~ Drug + Age + Stage + Bilirubin), data));\n# returns Mira of linear model outputs from each imputed dataset\n\njulia> resultsLMs = pool(analysesLMs);\n# returns Mipo of pooled linear model results","category":"page"},{"location":"whatsnext/#What's-next?","page":"What's next?","title":"What's next?","text":"","category":"section"},{"location":"whatsnext/","page":"What's next?","title":"What's next?","text":"Aspirational features for future releases include:","category":"page"},{"location":"whatsnext/","page":"What's next?","title":"What's next?","text":"Other imputation methods;\nSeamless integration with R and\nCUDA support.","category":"page"},{"location":"whatsnext/","page":"What's next?","title":"What's next?","text":"If you have any suggestions for features, please raise an issue on the issues page.","category":"page"},{"location":"imputation/#Imputation-(mice)","page":"Imputation (mice)","title":"Imputation (mice)","text":"","category":"section"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"The main function of the package is mice, which takes a DataFrame as its input. It returns a multiply imputed dataset (Mids) object with the imputed values.","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"Mids\nmice","category":"page"},{"location":"imputation/#Mice.Mids","page":"Imputation (mice)","title":"Mice.Mids","text":"Mids\n\nA multiply imputed dataset object.\n\nThe data originally supplied are stored as data.\n\nThe imputed data are stored as imputations (one column per imputation).\n\nThe number of imputations is stored as m.\n\nThe imputation method for each variable is stored as methods.\n\nThe predictor matrix is stored as predictorMatrix.\n\nThe order in which the variables are imputed is stored as visitSequence.\n\nThe number of iterations is stored as iter.\n\nThe mean of each variable across the imputations is stored as meanTraces.\n\nThe variance of each variable across the imputations is stored as varTraces.\n\n\n\n\n\n","category":"type"},{"location":"imputation/#Mice.mice","page":"Imputation (mice)","title":"Mice.mice","text":"mice(\n    data::DataFrame;\n    m::Int = 5,\n    visitSequence::Union{Vector{String}, Nothing} = nothing,\n    methods::Union{NamedVector{String}, Nothing} = nothing,\n    predictorMatrix::Union{NamedMatrix{Bool}, Nothing} = nothing,\n    iter::Int = 10,\n    progressReports::Bool = true,\n    gcSchedule::Float64 = 1.0,\n    threads::Bool = true,\n    kwargs...\n    )\n\nImputes missing values in a dataset using the MICE algorithm.  Heavily based on the R package mice (van Buuren & Groothuis-Oudshoorn, 2011).\n\nThe data containing missing values (data) must be supplied as a DataFrame.\n\nThe number of imputations created is specified by m.\n\nThe variables will be imputed in the order specified by visitSequence.  The default is sorted by proportion of missing data in ascending order;  the order can be customised using a vector of variable names in the desired order.\n\nThe imputation method for each variable is specified by the NamedArray methods.  The default is to use predictive mean matching (pmm) for all variables.  Currently only pmm is supported.  Any variable not to be imputed can be marked as such using an empty string (\"\").\n\nThe predictor matrix is specified by the NamedArray predictorMatrix.  The default is to use all other variables as predictors for each variable.  Any variable not predicting another variable can be marked as such in the matrix using a 0.\n\nThe number of iterations is specified by iter.\n\nIf progressReports is true, a progress indicator will be displayed in the console.\n\ngcSchedule dictates when the garbage collector will be (additionally) invoked. The  number provided is the fraction of your RAM remaining at which the GC will be called. For small datasets, you may get away with a value of 0.0 (never called), but for larger datasets, it may be worthwhile to call it more frequently. The default is to call it  after each iteration of each variable (1.0), but this may negatively affect performance if it is not necessary for your dataset.\n\nthreads dictates whether multi-threading will be used. This will improve performance for larger jobs if and only if Julia has been launched with multiple threads (which you can verify by calling Threads.nthreads()). The default is true.\n\n\n\n\n\nmice(\n    mids::Mids;\n    iter::Int = 10,\n    progressReports::Bool = true,\n    gcSchedule::Float64 = 1.0,\n    threads::Bool = true,\n    kwargs...\n    )\n\nAdds additional iterations to an existing Mids object.\n\nThe number of additional iterations is specified by iter.\n\nIf progressReports is true, a progress indicator will be displayed in the console.\n\ngcSchedule dictates when the garbage collector will be (additionally) invoked. The  number provided is the fraction of your RAM remaining at which the GC will be called. For small datasets, you may get away with a value of 0.0 (never called), but for larger datasets, it may be worthwhile to call it more frequently. The default is to call it  after each iteration of each variable (1.0), but this may negatively affect performance if it is not necessary for your dataset.\n\nthreads dictates whether multi-threading will be used. This will improve performance for larger jobs if and only if Julia has been launched with multiple threads (which you can verify by calling Threads.nthreads()). The default is true.\n\n\n\n\n\n","category":"function"},{"location":"imputation/#Customising-the-imputation-setup","page":"Imputation (mice)","title":"Customising the imputation setup","text":"","category":"section"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"You can customise various aspects of the imputation setup by passing keyword arguments to mice. These are described above. You can also use some of the functions below to define objects that you can customise to alter how mice handles the imputation.","category":"page"},{"location":"imputation/#Visit-sequence","page":"Imputation (mice)","title":"Visit sequence","text":"","category":"section"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"The visit sequence is the order in which the variables are imputed. By default, mice sorts the variables in order of missingness (lowest to highest) via the function makeMonotoneSequence.","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"makeMonotoneSequence","category":"page"},{"location":"imputation/#Mice.makeMonotoneSequence","page":"Imputation (mice)","title":"Mice.makeMonotoneSequence","text":"makeMonotoneSequence(data::DataFrame)\n\nReturns a vector of the column names in a DataFrame in ascending order of missingness. This facilitates convergence in cases where missingness follows a \"monotone\" pattern. It is the default visit sequence for the mice() function.\n\n\n\n\n\n","category":"function"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"You can instead define your own visit sequence by creating a vector of variable names in your desired order and passing that to mice. For example:","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"using DataFrames, Mice, Random\n\nmyData = DataFrame(\n    :col1 => Vector{Union{Missing, Float64}}([1.0, missing, 3.0, missing, 5.0]),\n    :col2 => Vector{Union{Missing, Int64}}([1, 2, missing, 4, 5]),\n    :col3 => Vector{Union{Missing, String}}([missing, \"2\", missing, \"4\", missing])\n);\n\nmakeMonotoneSequence(myData)\n# 3-element Vector{String}:\n# \"col2\"\n# \"col1\"\n# \"col3\"\n\nmyVisitSequence1 = names(myData)\n# 3-element Vector{String}:\n# \"col1\"\n# \"col2\"\n# \"col3\"\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\n# Not run\nmice(myData, visitSequence = myVisitSequence1)\n\nmyVisitSequence2 = [\"col3\", \"col1\", \"col2\"]\n# 3-element Vector{String}:\n# \"col3\"\n# \"col1\"\n# \"col2\"\n\n# Not run\nmice(myData, visitSequence = myVisitSequence2)","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"Assuming that the imputations converge normally, changing the visit sequence should not dramatically affect the output. However, it can be useful to change the visit sequence if you want to impute variables in a particular order for a specific reason. The sequence used by default in Mice.jl can make convergence faster in cases where the data follow a (near-)\"monotone\" missing data pattern [1].","category":"page"},{"location":"imputation/#Predictor-matrix","page":"Imputation (mice)","title":"Predictor matrix","text":"","category":"section"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"The predictor matrix defines which variables in the imputation model are used to predict which others. By default, every variable predicts every other variable, but there are a wide range of cases in which this is not desirable. For example, if your dataset includes an ID column, this is clearly useless for imputation and should be ignored.","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"To create a default predictor matrix that you can edit, you can use the function makePredictorMatrix.","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"makePredictorMatrix","category":"page"},{"location":"imputation/#Mice.makePredictorMatrix","page":"Imputation (mice)","title":"Mice.makePredictorMatrix","text":"makePredictorMatrix(data::DataFrame)\n\nReturns a named matrix of booleans defining the predictors for each variable in data. The variables to be predicted are on the rows, and the predictors are on the columns. The default is to use all variables as predictors for all other variables (i.e. all 1s except for the diagonal, which is 0).\n\n\n\n\n\n","category":"function"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"You can then edit the predictor matrix to remove any predictive relationships that you do not want to include in the imputation model. For example:","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"using DataFrames, Mice, Random\n\nmyData = DataFrame(\n    :id => Vector{Int64}(1:5),\n    :col1 => Vector{Union{Missing, Float64}}([1.0, missing, 3.0, missing, 5.0]),\n    :col2 => Vector{Union{Missing, Int64}}([1, 2, missing, 4, 5]),\n    :col3 => Vector{Union{Missing, String}}([missing, \"2\", missing, \"4\", missing])\n);\n\nmyPredictorMatrix = makePredictorMatrix(myData)\n# 4x4 Named Matrix{Bool}\n# A \\ B |    id   col1   col2   col3\n# ------|---------------------------\n# id    | false   true   true   true\n# col1  |  true  false   true   true\n# col2  |  true   true  false   true\n# col3  |  true   true   true  false\n\n# To stop the ID column from predicting any other variable\nmyPredictorMatrix[:, \"id\"] .= false;\nmyPredictorMatrix\n# 4x4 Named Matrix{Bool}\n# A \\ B |    id   col1   col2   col3\n# ------|---------------------------\n# id    | false   true   true   true\n# col1  | false  false   true   true\n# col2  | false   true  false   true\n# col3  | false   true   true  false\n\n# To stop col1 from predicting col3\nmyPredictorMatrix[\"col3\", \"col1\"] = false;\nmyPredictorMatrix\n# 4x4 Named Matrix{Bool}\n# A \\ B |    id   col1   col2   col3\n# ------|---------------------------\n# id    | false   true   true   true\n# col1  | false  false   true   true\n# col2  | false   true  false   true\n# col3  | false  false   true  false\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\n# Not run\nmice(myData, predictorMatrix = myPredictorMatrix)","category":"page"},{"location":"imputation/#Methods","page":"Imputation (mice)","title":"Methods","text":"","category":"section"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"The imputation methods are the functions that are used to impute each variable. By default, mice uses predictive mean matching (\"pmm\") for all variables (and currently PMM is the only method that Mice.jl supports). However, you can use the methods vector to specify any variables that should not be imputed.","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"To create a default methods vector, use the function makeMethods.","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"makeMethods","category":"page"},{"location":"imputation/#Mice.makeMethods","page":"Imputation (mice)","title":"Mice.makeMethods","text":"makeMethods(data::DataFrame)\n\nReturns a named vector of strings defining the method by which each variable in data should be imputed in the mice() function. The default (and only supported) method is predictive mean matching (pmm).\n\n\n\n\n\n","category":"function"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"You can then customise the vector as needed. For example:","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"using DataFrames, Mice, Random\n\nmyData = DataFrame(\n    :id => Vector{Int64}(1:5),\n    :col1 => Vector{Union{Missing, Float64}}([1.0, missing, 3.0, missing, 5.0]),\n    :col2 => Vector{Union{Missing, Int64}}([1, 2, missing, 4, 5]),\n    :col3 => Vector{Union{Missing, String}}([missing, \"2\", missing, \"4\", missing])\n);\n\nmyMethods = makeMethods(myData)\n# 4-element Named Vector{String}\n# A    |\n# -----|------\n# id   | \"pmm\"\n# col1 | \"pmm\"\n# col2 | \"pmm\"\n# col3 | \"pmm\"\n\n# To stop the ID column from being imputed\nmyMethods[\"id\"] = \"\";\nmyMethods\n# 4-element Named Vector{String}\n# A    |\n# -----|------\n# id   |    \"\"\n# col1 | \"pmm\"\n# col2 | \"pmm\"\n# col3 | \"pmm\"\n\nRandom.seed!(1234); # Set random seed for reproducibility\n\n# Not run\nmice(myData, methods = myMethods)","category":"page"},{"location":"imputation/#Diagnostics","page":"Imputation (mice)","title":"Diagnostics","text":"","category":"section"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"After performing multiple imputation, you should inspect the trace plots of the imputed variables to verify convergence. Mice.jl includes the a plotting function to do this.","category":"page"},{"location":"imputation/","page":"Imputation (mice)","title":"Imputation (mice)","text":"plot","category":"page"},{"location":"imputation/#RecipesBase.plot","page":"Imputation (mice)","title":"RecipesBase.plot","text":"plot(\n    mids::Mids,\n    var::String\n    )\n\nPlots the mean and standard deviation of the imputed values for a given variable. Here var is given as a string (the name of the variable).\n\n\n\n\n\nplot(\n    mids::Mids,\n    var_no::Int\n    )\n\nPlots the mean and standard deviation of the imputed values for a given variable. Here var_no is given as an integer (the index of the variable in the visitSequence).\n\n\n\n\n\n","category":"function"},{"location":"#Getting-started","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"#Installation","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"To install Mice.jl through the Julia REPL, you can type ] add Mice or:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"using Pkg\nPkg.add(\"Mice\")","category":"page"},{"location":"#Usage","page":"Getting started","title":"Usage","text":"","category":"section"},{"location":"","page":"Getting started","title":"Getting started","text":"To load the package, use the command:","category":"page"},{"location":"","page":"Getting started","title":"Getting started","text":"using Mice","category":"page"}]
}
