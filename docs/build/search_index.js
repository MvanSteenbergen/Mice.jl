var documenterSearchIndex = {"docs":
[{"location":"#Mice.jl","page":"Mice.jl","title":"Mice.jl","text":"","category":"section"},{"location":"","page":"Mice.jl","title":"Mice.jl","text":"Mids\nmice","category":"page"},{"location":"#Mice.Mids","page":"Mice.jl","title":"Mice.Mids","text":"Mids\n\nA multiply imputed dataset object.\n\nThe data originally supplied are stored as data.\n\nThe imputed data are stored as imputations (one column per imputation).\n\nThe number of imputations is stored as m.\n\nThe imputation method for each variable is stored as methods.\n\nThe predictor matrix is stored as predictorMatrix.\n\nThe order in which the variables are imputed is stored as visitSequence.\n\nThe number of iterations is stored as iter.\n\nThe mean of each variable across the imputations is stored as meanTraces.\n\nThe variance of each variable across the imputations is stored as varTraces.\n\n\n\n\n\n","category":"type"},{"location":"#Mice.mice","page":"Mice.jl","title":"Mice.mice","text":"mice(\n    data::DataFrame;\n    m::Int = 5,\n    visitSequence::Union{Vector{String}, Nothing} = nothing,\n    methods::Union{NamedVector{String}, Nothing} = nothing,\n    predictorMatrix::Union{NamedMatrix{Bool}, Nothing} = nothing,\n    iter::Int = 10,\n    progressReports::Bool = true,\n    gcSchedule::Float64 = 1.0,\n    threads::Bool = true,\n    kwargs...\n    )\n\nImputes missing values in a dataset using the MICE algorithm.  Heavily based on the R package mice (van Buuren & Groothuis-Oudshoorn, 2011).\n\nThe data containing missing values (data) must be supplied as a DataFrame.\n\nThe number of imputations created is specified by m.\n\nThe variables will be imputed in the order specified by visitSequence.  The default is sorted by proportion of missing data in ascending order;  the order can be customised using a vector of variable names in the desired order.\n\nThe imputation method for each variable is specified by the NamedArray methods.  The default is to use predictive mean matching (pmm) for all variables.  Currently only pmm is supported.  Any variable not to be imputed can be marked as such using an empty string (\"\").\n\nThe predictor matrix is specified by the NamedArray predictorMatrix.  The default is to use all other variables as predictors for each variable.  Any variable not predicting another variable can be marked as such in the matrix using a 0.\n\nThe number of iterations is specified by iter.\n\nIf progressReports is true, a progress indicator will be displayed in the console.\n\ngcSchedule dictates when the garbage collector will be (additionally) invoked. The  number provided is the fraction of your RAM remaining at which the GC will be called. For small datasets, you may get away with a value of 0.0 (never called), but for larger datasets, it may be worthwhile to call it more frequently. The default is to call it  after each iteration of each variable (1.0), but this may negatively affect performance if it is not necessary for your dataset.\n\nthreads dictates whether multi-threading will be used. This will improve performance for larger jobs if and only if Julia has been launched with multiple threads (which you can verify by calling Threads.nthreads()). The default is true.\n\n\n\n\n\nmice(\n    mids::Mids;\n    iter::Int = 10,\n    progressReports::Bool = true,\n    gcSchedule::Float64 = 1.0,\n    threads::Bool = true,\n    kwargs...\n    )\n\nAdds additional iterations to an existing Mids object.\n\nThe number of additional iterations is specified by iter.\n\nIf progressReports is true, a progress indicator will be displayed in the console.\n\ngcSchedule dictates when the garbage collector will be (additionally) invoked. The  number provided is the fraction of your RAM remaining at which the GC will be called. For small datasets, you may get away with a value of 0.0 (never called), but for larger datasets, it may be worthwhile to call it more frequently. The default is to call it  after each iteration of each variable (1.0), but this may negatively affect performance if it is not necessary for your dataset.\n\nthreads dictates whether multi-threading will be used. This will improve performance for larger jobs if and only if Julia has been launched with multiple threads (which you can verify by calling Threads.nthreads()). The default is true.\n\n\n\n\n\n","category":"function"}]
}
